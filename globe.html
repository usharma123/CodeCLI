<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Globe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            overflow: hidden;
            color: white;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00d4ff, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        p {
            font-size: 0.9em;
            opacity: 0.8;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 15px;
        }

        button {
            background: linear-gradient(45deg, #00d4ff, #0099ff);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>üåç Interactive 3D Globe</h1>
        <p>Drag to rotate ‚Ä¢ Scroll to zoom</p>
    </div>

    <div id="container"></div>

    <div id="controls">
        <button onclick="toggleRotation()">‚èØ Toggle Rotation</button>
        <button onclick="resetView()">üîÑ Reset View</button>
        <button onclick="toggleWireframe()">üåê Toggle Wireframe</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, globe, clouds;
        let isRotating = true;
        let isWireframe = false;
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 3;

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // Create Earth
            const geometry = new THREE.SphereGeometry(1, 64, 64);
            
            // Earth texture (using a simple gradient for now)
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Create ocean base
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1e3a5f');
            gradient.addColorStop(0.5, '#2a5f8f');
            gradient.addColorStop(1, '#1e3a5f');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add continents (simplified)
            ctx.fillStyle = '#2d5016';
            // North America
            ctx.fillRect(200, 300, 400, 300);
            // South America
            ctx.fillRect(400, 600, 250, 350);
            // Europe
            ctx.fillRect(900, 250, 300, 200);
            // Africa
            ctx.fillRect(950, 450, 350, 400);
            // Asia
            ctx.fillRect(1200, 200, 600, 500);
            // Australia
            ctx.fillRect(1500, 700, 250, 200);
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                bumpScale: 0.05,
                specular: new THREE.Color('#333333'),
                shininess: 5
            });
            
            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            // Add clouds layer
            const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
            const cloudCanvas = document.createElement('canvas');
            cloudCanvas.width = 2048;
            cloudCanvas.height = 1024;
            const cloudCtx = cloudCanvas.getContext('2d');
            
            // Create cloud pattern
            cloudCtx.fillStyle = 'rgba(255, 255, 255, 0)';
            cloudCtx.fillRect(0, 0, cloudCanvas.width, cloudCanvas.height);
            cloudCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * cloudCanvas.width;
                const y = Math.random() * cloudCanvas.height;
                const radius = Math.random() * 100 + 50;
                cloudCtx.beginPath();
                cloudCtx.arc(x, y, radius, 0, Math.PI * 2);
                cloudCtx.fill();
            }
            
            const cloudTexture = new THREE.CanvasTexture(cloudCanvas);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.4
            });
            
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(clouds);

            // Atmosphere glow
            const atmosphereGeometry = new THREE.SphereGeometry(1.15, 64, 64);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x4488ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            // Stars background
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.02
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);

            // Mouse controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);

            // Touch controls
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isRotating) {
                globe.rotation.y += 0.002;
                clouds.rotation.y += 0.0025;
            }

            renderer.render(scene, camera);
        }

        function onMouseDown(event) {
            mouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (mouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                globe.rotation.y += deltaX * 0.005;
                globe.rotation.x += deltaY * 0.005;
                clouds.rotation.y += deltaX * 0.005;
                clouds.rotation.x += deltaY * 0.005;

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseUp() {
            mouseDown = false;
        }

        function onWheel(event) {
            event.preventDefault();
            camera.position.z += event.deltaY * 0.001;
            camera.position.z = Math.max(1.5, Math.min(5, camera.position.z));
        }

        let touchStartX = 0, touchStartY = 0;

        function onTouchStart(event) {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }

        function onTouchMove(event) {
            event.preventDefault();
            const deltaX = event.touches[0].clientX - touchStartX;
            const deltaY = event.touches[0].clientY - touchStartY;

            globe.rotation.y += deltaX * 0.005;
            globe.rotation.x += deltaY * 0.005;
            clouds.rotation.y += deltaX * 0.005;
            clouds.rotation.x += deltaY * 0.005;

            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }

        function onTouchEnd() {
            // Touch ended
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleRotation() {
            isRotating = !isRotating;
        }

        function resetView() {
            camera.position.z = 3;
            globe.rotation.x = 0;
            globe.rotation.y = 0;
            clouds.rotation.x = 0;
            clouds.rotation.y = 0;
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            globe.material.wireframe = isWireframe;
        }

        // Initialize the scene
        init();
    </script>
</body>
</html>